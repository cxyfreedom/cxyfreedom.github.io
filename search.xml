<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python源码解析——可重入锁RLock]]></title>
    <url>%2Fpython-source-code-parse-with-rlock%2F</url>
    <content type="text"><![CDATA[源码（带注释）可重入锁 RLock 的源码在 threading.py 文件中 1234567891011121314151617181920212223242526272829303132333435363738394041def RLock(*args, **kwargs): """ 该工厂函数返回一个新的可重入锁。 一个可重入锁必须由创建它的线程释放。一旦一个线程获得了一个可重入锁，该线程可用无阻塞的再次获取。每次获取锁后必须进行释放。 Python支持用C语言实现的 RLock 锁和用Python本身实现的 RLock 锁，默认使用的是C语言版本的 """ if _CRLock is None: return _PyRLock(*args, **kwargs) return _CRLock(*args, **kwargs)class _RLock: # RLock的核心即 acquire 和 release 这两个方法 def __init__(self): self._block = _allocate_lock() # 分配一个锁 self._owner = None # RLock对象所属的线程pid self._count = 0 # 锁计数器，对于RLock对象所在线程，每获取一次就加一，相对的每次释放就减一，当减到零时，就会释放内部创建的锁，这样其他线程就可以继续获得这个锁。 def acquire(self, blocking=True, timeout=-1): me = get_ident() # 获取当前线程的pid if self._owner == me: # 如果当前线程的pid是RLock对象所在的线程，那么对计数器进行加一操作 self._count += 1 return 1 # 如果不满足上述条件： # 1. 当前线程非RLock对象所在线程 # 2. RLock对象还未持有锁，即 self.owner = None # 那么当 blocking=True 时，当前线程被阻塞，直到持有锁的线程将锁释放后，rc = True # 当 blocking=False 时，可以非阻塞的获取。如果获取锁成功，rc = True；获取失败，rc = False rc = self._block.acquire(blocking, timeout) if rc: self._owner = me # 记录持有锁的线程的pid self._count = 1 # 将计数器重置到1 return rc def release(self): if self._owner != get_ident(): # 如果持有锁的线程非当前线程，则抛异常 raise RuntimeError("cannot release un-acquired lock") self._count = count = self._count - 1 # 每次释放对计数器进行减一 if not count: # 如果计数器减到0，那么释放RLock内部的锁，此时其他线程就可以获取到锁 self._owner = None # 还原RLock对象持有锁的拥有者None self._block.release() # 释放锁 acquire 方法流程图 release 方法流程图 示例为了验证上述分析内容，对源码增加一些打印，便于我们了解实际的运行机制。 测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import threadingclass _RLock: def __init__(self): self._lock = threading.Lock() self._owner = 0 self._count = 0 def acquired(self, block=True, timeout=-1): me = threading.get_ident() if self._owner == me: self._count += 1 print(f"acquired count = &#123;self._count&#125;") return 1 rc = self._lock.acquire(block, timeout) if rc: self._count = 1 print(f"acquired count = &#123;self._count&#125;") self._owner = me return rc def release(self): me = threading.get_ident() if self._owner != me: raise RuntimeError("can not release the un-acquired the lock") self._count = count = self._count - 1 print(f"release count = &#123;self._count&#125;") if not count: self._owner = None self._lock.release()def worker(lock): print("====非可重入锁所在线程释放RLock内部锁====") pid = threading.current_thread() print(f"current pid = &#123;pid&#125;") try: lock.release() except Exception as e: print(str(e)) print("====非可重入锁所在线程释放RLock内部锁失败====") print("waiting......") lock.acquired() print(f"RLock所在线程已释放所有锁，worker线程获取RLock内部锁成功")if __name__ == '__main__': print("生成一个R锁对象") rlock = RLock() print("主线程获取RLock") z = rlock.acquired() print(f"current pid = &#123;threading.current_thread()&#125;") print("创建并启动一个worker线程") t = threading.Thread(target=worker, args=(rlock,)) t.start() print("主线程开始获取RLock锁") for i in range(5): rlock.acquired() print("主线程释放RLock锁") for i in range(6): rlock.release() print("主线程释放完所有的RLock锁") 测试代码使用两个线程，一个主线程，一个是 worker 线程。运行结果如下：（实际结果可能有所出入，但是不影响实际请求流程） 1234567891011121314151617181920212223242526生成一个R锁对象主线程获取RLockacquired count = 1current pid = &lt;_MainThread(MainThread, started 140736157979584)&gt;创建并启动一个worker线程====非可重入锁所在线程释放RLock内部锁====主线程开始获取RLock锁acquired count = 2acquired count = 3acquired count = 4acquired count = 5acquired count = 6主线程释放RLock锁release count = 5release count = 4release count = 3release count = 2current pid = &lt;Thread(Thread-1, started 123145446993920)&gt;can not release the un-acquired the lock====非可重入锁所在线程释放RLock内部锁失败====waiting......release count = 1release count = 0主线程释放完所有的RLock锁acquired count = 1RLock所在线程已释放所有锁，worker线程获取RLock内部锁成功 st=>start: 调用 acquire e1=>end: return 1 e2=>end: return rc op1=>operation: 获取当前线程的pid cond1=>condition: 当前线程是否为RLock对象所属线程？ op2=>operation: 计数器_count加1 op3=>operation: 获取内部互斥锁 cond2=>condition: 获取锁是否成功？ op4=>operation: 将当前线程的pid赋给_owner，并将_count设置为1 st->op1->cond1 cond1(yes)->op2->e1 cond1(no, left)->op3->cond2 cond2(yes)->op4->e2 cond2(no, left)->e2{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 调用 release e1=>end: 抛出异常 e2=>end: return op1=>operation: 获取当前线程的pid cond1=>condition: 当前线程是否为RLock对象所属线程？ op2=>operation: 计数器_count减1 cond2=>condition: count是否为0？ op3=>operation: _owner还原为None，并释放内部锁 st->op1->cond1 cond1(yes, left)->op2->cond2 cond1(no)->e1 cond2(yes)->op3->e2 cond2(no)->e2{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);]]></content>
      <tags>
        <tag>Python</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT 主题优化]]></title>
    <url>%2Fhexo-next-optimization%2F</url>
    <content type="text"><![CDATA[元素微调自定义篇定位元素用谷歌或者火狐浏览器打开博客页面，按下F12进入调试先点击定位按钮，然后选择元素，然后在定位出来的样式进行修改，调到自己喜欢的样子。 有趣的样式在 themes/next/source/css/_custom/custom.styl 中添加以下样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243/*有趣的自定义样式*/// 下载样式a#download &#123; display: inline-block; padding: 0 10px; color: #000; background: transparent; border: 2px solid #000; border-radius: 2px; transition: all .5s ease; font-weight: bold; &amp;:hover &#123; background: #000; color: #fff; &#125;&#125;// 颜色块-黄span#inline-yellow &#123; display: inline; padding: .2em .6em .3em; font-size: 80%; font-weight: bold; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: 0; background-color: #f0ad4e;&#125;// 颜色块-绿span#inline-green &#123; display: inline; padding: .2em .6em .3em; font-size: 80%; font-weight: bold; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: 0; background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123; display: inline; padding: .2em .6em .3em; font-size: 80%; font-weight: bold; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: 0; background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123; display: inline; padding: .2em .6em .3em; font-size: 80%; font-weight: bold; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: 0; background-color: #9954bb;&#125;// 左侧边框红色块级p#div-border-left-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-left-width: 5px; border-radius: 3px; border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-right-width: 5px; border-radius: 3px; border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-top-width: 5px; border-radius: 3px; border-top-color: #9954bb;&#125; 用法如下： 文字增加背景色块站点配置文件，主题配置文件 12&lt;span id="inline-blue"&gt;站点配置文件&lt;/span&gt;，&lt;span id="inline-purple"&gt;主题配置文件&lt;/span&gt; 引用边框变色如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 12&lt;p id="div-border-left-red"&gt;如果没有安装成功，那可能就是墙的原因。建议下载 `Node.js` 直接安装。&lt;/p&gt;&lt;p id="div-border-top-blue"&gt;关于更多基本操作和基础知识，请查阅 [Hexo](https://hexo.io/zh-cn/) 与 [NexT](http://theme-next.iissnan.com/) 官方文档.&lt;/p&gt; 在文档中增加图标 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一件部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 123456* &lt;i class="fa fa-pencil"&gt;&lt;/i&gt;支持Markdown&lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。&lt;/i&gt;* &lt;i class="fa fa-cloud-upload"&gt;&lt;/i&gt;一件部署&lt;i&gt;只需一条指令即可部署到Github Pages，或其他网站&lt;/i&gt;* &lt;i class="fa fa-cog"&gt;&lt;/i&gt;丰富的插件&lt;i&gt;Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。&lt;/i&gt; 更多示例 &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; 采用的是Font Awesome的图标。 图形边框效果自定义效果： Download Now 源码12&lt;a id=&quot;download&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt;&lt;span&gt; Download Now&lt;/span&gt;&lt;/a&gt; 主题自带效果：点击访问博客 源码1&#123;% btn https://reishin.me, 点击访问博客, home fa-fw %&#125; 更多使用方法参考该页面。 代码块样式效果： PythonGithub1print("Hello, NexT") 用法： 12```[language] [title] [url] [link-text]code [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须； [title] 是顶部左边的说明，非必须； [url] 是顶部右边的超链接地址，非必须； [link text] 如它的字面意思，超链接的名称，非必须。 代码高亮的语言名称可以参考这篇文章 如关于代码块高亮的高级个性化，参考HEXO下的语法高亮拓展修改 文本居中引用效果： 居中引用 源码123&#123;% cq %&#125;居中引用&#123;% endcq %&#125; 更多 NexT 主题自带的标签样式 主题自带的 note 标签default 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; primary 1&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt; success 1&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt; info 1&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; warning 1&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt; danger 1&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; danger no-icon 1&lt;div class="note danger no-icon"&gt;&lt;p&gt;danger no-icon&lt;/p&gt;&lt;/div&gt; 具体的风格查看该页面 插入音乐和视频音乐 安装1npm install hexo-tag-aplayer --save 写法1&#123;% meting &quot;421137682&quot; &quot;netease&quot; &quot;song&quot; %&#125; 具体使用方法参考 hexo-tag-aplayer 或者 官方文档 视频 (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://p64urweu3.bkt.clouddn.com/%E4%B8%8D%E8%80%81%E6%A2%A6.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 安装1npm install hexo-tag-dplayer --save 具体使用方法参考 hexo-tag-dplayer 或者 官方文档 插件汇总字数与阅读时间插件1npm install hexo-symbols-count-time --save 部署插件1npm install hexo-deployer-git --save 分享插件1git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton RSS插件1npm install hexo-generator-feed --save 百度主动推送插件1npm install hexo-baidu-url-submit --save sitemap12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 动画效果插件1234git clone https://github.com/theme-next/theme-next-three source/lib/threegit clone https://github.com/theme-next/theme-next-pace source/lib/pacegit clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nestgit clone https://github.com/theme-next/theme-next-canvas-ribbon source/lib/canvas-ribbon 萌宠插件1npm install hexo-helper-live2d@2.1.5 --save 然后在 /next/layout/_layout.swig 的 &lt;/body&gt; 之前加入 1&#123;&#123; live2d() &#125;&#125; _config.yml1234live2d: model: koharu position: left opacityDefault: 1 hexo live2d插件 2.0官方文档 写作篇新建文章1$ hexo new post &lt;title&gt; 使用 Markdown教程HEXO下的Markdown语法(GFM)写博客 主题升级备份NexT作者给我们的建议就是使用 Data Files，具体详情看 官方使用说明 使用NexT方式 使用这一方式，你现在可以将你的全部配置置于同一位置（source/_data/next.yml），并且不需要修改 next/_config.yml。 但是可能无法让所有 Hexo 外部库都准确处理它们的附加选项（举个例子，hexo-server 模块只会从 Hexo 默认配置文件中读取选项）。 用法 请确认你的 Hexo 版本为 3.0 或更高。 在你站点的 hexo/source/_data 目录创建一个 next.yml 文件（如果 _data 目录不存在，请创建之）。 以上步骤之后有 两种选择，请任选其一然后继续后面的步骤。 选择 1：override: false（默认）： 检查默认 NexT 配置中的 override 选项，必须设置为 false。\在 next.yml 文件中，也要设置为 false，或者不定义此选项。 从站点的 _config.yml 与主题的 _config.yml 中复制你需要的选项到 hexo/source/_data/next.yml 中。 选择 2：override: true： 在 next.yml 中设置 override 选项为 true。 从 next/_config.yml 配置文件中复制所有的 NexT 主题选项到 hexo/source/_data/next.yml 中。 然后，在站点的 hexo/_config.yml中需要定义 theme: next 选项（如果需要的话，source_dir: source）。 使用标准参数来启动服务器，生成或部署（hexo clean &amp;&amp; hexo g -d &amp;&amp; hexo s）。 参考文章 hexo的next主题个性化教程:打造炫酷网站 Hexo与Disqus引入的故事 Hexo Next 主题点击加载 Disqus 和来必力双评论系统 【高阶】NexT 主题优化之加入网易云音乐、网易云跟帖、动态背景、自定义主题、统计功能 Hexo+NexT 主题配置备忘 Hexo-NexT搭建个人博客（二） 基于Hexo搭建个人博客——进阶篇(从入门到入土) 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 TODO 使用 emoji 表情]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages 启用 SSL/TLS]]></title>
    <url>%2FHexo-with-SSL-hosted-on-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[注册 CloudFlare注册 CloudFlare 后，按照提示在 Add Websites 中添加自己网站的域名，然后点击 Begin Scan 通常情况一路默认即可。最后，CloudFlare 会分配两个 NameServer ，比如： *.ns.cloudflare.com *.ns.cloudflare.com 修改域名服务商的 NameServer理论上可以添加多个 NameServer，但混用多个可能会导致一些问题，所以建议直接将原有的 NS 替换 为 CloudFlare 提供的 NS。例如 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net。添加完毕后，等待 片刻，在 CloudFlare 中点击 Recheck Nameservers，如果激活成功，会提示 Status: Active。 到此为止，已经可以用 https 来访问你的网站。 强制网页跳转 HTTPS现在我们需要手动在地址栏输入 https 才能访问我们加密的网站。为了能够访问网站的任何一个页面 时，都能够以加密方式进行访问，最为便捷的方式就是使用 CloudFlare 提供的 Page Rules。设置规 则类似于如下： 参考链接 为 Github的 Hexo 博客启用 SSL/TLS 在 GitHub Pages上使用 CloudFlare https CDN 再谈域名 DNS 服务器不能混用多个 NS 的问题 CloudFlare]]></content>
      <tags>
        <tag>SSL</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Hexo + GitHub搭建个人博客]]></title>
    <url>%2F%E5%88%A9%E7%94%A8Hexo-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言网上看到各式各样的博客，因此，自己也想拥有一个属于自己的独立博客。利用搜索引擎，最终选择了 Hexo + Github 的方式来搭建一个静态博客。搭建完成后，决定把自己从开始到搭建完成的整个过程给记录下来，也可以给以后搭建博客的人一个参考。 安装前提 Git Node.js 我是在Ubuntu平台上搭建的，所以就以Ubuntu下为例： 安装 Git1$ sudo apt-get install git-core 安装 Node.js 脚本安装 123$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash# or$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.2/install.sh | bash 手动安装 123456789export NVM_DIR="$HOME/.nvm" &amp;&amp; ( git clone https://github.com/creationix/nvm.git "$NVM_DIR" cd "$NVM_DIR" git checkout `git describe --abbrev=0 --tags --match "v[0-9]*" origin`) &amp;&amp; . "$NVM_DIR/nvm.sh"# 添加以下内容到~/.bashrc或者~/.profile或者~/.zshrcexport NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; . "$NVM_DIR/nvm.sh" # This loads nvm 安装完毕后，重启终端，然后执行以下命令12$ nvm install v6.2.2$ nvm alias default v6.2.2 开始搭建博客安装 Hexo12$ npm install -g hexo-cli$ npm install hexo --save 如果上述命令无法安装，可以将官方源替换成淘宝npm源1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 查看 Hexo 版本12345678910111213$ hexo versionhexo: 3.2.2hexo-cli: 1.0.2os: Linux 3.13.0-32-generic linux ia32http_parser: 2.7.0node: 6.2.2v8: 5.0.71.52uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2h 配置 Hexo123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ sudo npm install 部署 Hexo执行以下命令，启动本地服务器。然后在浏览器中输入 http://localhost:4000 即可访问1$ hexo s #启动本地服务器 博客部署到 GitHub新建一个博客的项目仓库Repository name 为your_github_name.github.io 配置本地的 SSH KEY 到 GitHub123$ ssh-keygen -t rsa -C "your email address" # 默认生成的文件名为id_rsa和id_rsa.pub# or$ ssh-keygen -t ras -C "your email address" -f "file_name" # 生成的文件名就为file_name和file_name.pub 然后在GitHub上新建一个SSH KEYS，把 *.pub 的内容拷贝进去。可以使用以下命令来测试是否设置成功1$ ssh -T git@github.com 把本地 Hexo 部署到 GitHub首先，需要修改站点的配置文件 _config.yml, 在文件中添加1234deploy: type: git repository: https://github.com/cxyfreedom/cxyfreedom.github.io.git branch: master 然后执行以下命令，就能够很容易把 Hexo 部署到 GitHub 上面123$ hexo clean #清除缓存$ hexo g # 生成静态文件$ hexo d # 部署网站 正常情况下，稍微等一会儿，输入XXX.github.io就能看到搭建好的博客了～ 绑定独立域名 购买独立域名域名购买我是选择通过 Godaddy, 找个优惠码注册，购买，一般没有什么问题 域名解析因为Godaddy的关系，我把域名解析移到了国内，我选择了 DNSPOD, 目前来说还是比较稳定的 绑定域名在你博客根目录下的 source 中，新建一个 CNAME 文件。在文件中填写你的域名。例如 reishin.me 最后部署到 GitHub 上面 博客同步和备份由于我们可能会在不同的 PC 上进行文章的编写，那么自然而然的我们需要同步我们的博客。因为有些配置文件涉及到一些隐私数据，所以为了安全起见，我选择了用 bitbucket 上建立一个私有仓库，然后把整个 Hexo 的文件用 git 来备份到仓库。因为 Hexo 的主题文件默认是不会同步的，为了便于博客更好的同步更新，我另外使用了一个 git-backup 的插件，这个插件可以备份整个博客，包括主题。 1.新建仓库并配置 SSH KEY 到 bitbucket 上 2.安装插件 1$ npm install hexo-git-backup --save # install base on 3.x.x 3.配置文件 在根目录下的 _config.yml 添加以下内容 123456backup: type: git theme: `theme` message: `commit的内容` repository: bitbucket: git@bitbucket.org:xxx/xxx.git,branchName 4.备份博客 1$ hexo b 5.同步博客 123456# 依次安装 git 和 nodejs$ npm install -g hexo-cli$ git clone git@bitbucket.org:cxyfreedom/hexo-blog.git$ cd hexo-blog$ npm install hexo --save$ npm install 总结第一次搭建博客的确花了不少时间，虽然搭建的过程大同小异，但是自己也遇到了很多配置上面的问题，所以只有耐心尝试，才能真正的搭建自己的博客。相比其他搭建博客的方式，Hexo + GitHub 这种方式的确更加简便，可塑性也非常高。 目前还只是初步搭建完成，还有很多细节的地方需要完善。博客也只是个平台，要坚持写文章才能让博客有意义，现在还只是个开始。 这篇文章只是大致描述了搭建的过程，如果能够对你有帮助，真是再好不过了～欢迎相互交流～ 参考链接[1] 如何搭建一个独立博客——简明 Github Pages与 jekyll 教程[2] Hexo 静态博客使用指南[3] 利用 git 解决 hexo 博客多PC间同步问题[4] 使用 hexo，如果换了电脑怎么更新博客？[5] Hexo 官网 更新日志 [2016.01.15] 增加一些步骤的细节和同步的方法 [2016.07.04] 更新主题版本，修正一些细节]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
